<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>chat-engine/src/index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Guides</h3><ul><li data-sidebar="getting-started"><a href="tutorial-getting-started.html">Getting Started</a><ul><li data-sidebar="node"><a href="tutorial-node.html">Set Up NodeJS</a></li><li data-sidebar="install"><a href="tutorial-install.html">Installing Chat Engine</a></li><li data-sidebar="pubnub"><a href="tutorial-pubnub.html">Set Up PubNub</a></li><li data-sidebar="configure"><a href="tutorial-configure.html">Configure the SDK</a></li></ul></li><li data-sidebar="concepts"><a href="tutorial-concepts.html">Concepts</a><ul><li data-sidebar="me"><a href="tutorial-me_.html">Me</a></li><li data-sidebar="users"><a href="tutorial-users.html">Users and State</a></li><li data-sidebar="chats"><a href="tutorial-chats.html">Chats</a></li><li data-sidebar="globalChat"><a href="tutorial-globalChat.html">Global Chat</a></li><li data-sidebar="events"><a href="tutorial-events.html">Events</a></li><li data-sidebar="payload"><a href="tutorial-payload.html">Event Payload</a></li><li data-sidebar="wildcard"><a href="tutorial-wildcard.html">Namespaces and Wildcards</a></li><li data-sidebar="online-list"><a href="tutorial-online-list.html">Online List</a></li><li data-sidebar="using"><a href="tutorial-using.html">Plugins</a></li><li data-sidebar="build"><a href="tutorial-build.html">Build a Plugin</a></li></ul></li><li data-sidebar="angular"><a href="tutorial-angular.html">Angular</a><ul><li data-sidebar="ng-simple"><a href="tutorial-ng-simple.html">Simple</a></li><li data-sidebar="ng-flowtron"><a href="tutorial-ng-flowtron.html">Flowtron</a></li></ul></li><li data-sidebar="topology"><a href="tutorial-topology.html">topology</a><ul></ul></li><li data-sidebar="jquery"><a href="tutorial-jquery.html">jQuery</a><ul><li data-sidebar="full"><a href="tutorial-full.html">Setting Up</a></li><li data-sidebar="jq-simple"><a href="tutorial-jq-simple.html">Simple</a></li><li data-sidebar="jq-kitchen"><a href="tutorial-jq-kitchen.html">Kitchen Sink</a></li></ul></li><li data-sidebar="js"><a href="tutorial-js.html">Javacsript</a><ul><li data-sidebar="chat"><a href="tutorial-chat_.html">Chat</a></li><li data-sidebar="friends"><a href="tutorial-friends.html">Friends List</a></li><li data-sidebar="online"><a href="tutorial-online.html">Online List</a></li><li data-sidebar="facebook"><a href="tutorial-facebook.html">Facebook Auth</a></li></ul></li><li data-sidebar="nodejs"><a href="tutorial-nodejs.html">NodeJS</a><ul><li data-sidebar="chatbot"><a href="tutorial-chatbot.html">Chat Bot</a></li></ul></li><li data-sidebar="react"><a href="tutorial-react.html">React</a><ul><li data-sidebar="react-simple"><a href="tutorial-react-simple.html">Web</a></li><li data-sidebar="react-native"><a href="tutorial-react-native.html">Native</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#ChatEngineCore">ChatEngineCore</a></li></ul><h3>Plugins</h3><ul><li data-sidebar="chat-engine-desktop-notifications"><a href="module-chat-engine-desktop-notifications.html">chat-engine-desktop-notifications</a></li><li data-sidebar="chat-engine-emoji"><a href="module-chat-engine-emoji.html">chat-engine-emoji</a><ul><li><a href="Chat.html">Chat</a><ul class='members'></ul><ul class='methods'><li data-type='method'><a href="module-chat-engine-emoji.html#~parseEmoji">parseEmoji()</a></li><li data-type='method'><a href="module-chat-engine-emoji.html#~render">render()</a></li><li data-type='method'><a href="module-chat-engine-emoji.html#~search">search()</a></li></ul></ul></li><li data-sidebar="chat-engine-gravatar"><a href="module-chat-engine-gravatar.html">chat-engine-gravatar</a><ul><li><a href="User.html">User</a><ul class='members'><li data-type='member'><a href="module-chat-engine-gravatar.html#~state()%2522.%2522gravatar">state().gravatar</a></li></ul></ul></li><li data-sidebar="chat-engine-markdown"><a href="module-chat-engine-markdown.html">chat-engine-markdown</a></li><li data-sidebar="chat-engine-online-user-search"><a href="module-chat-engine-online-user-search.html">chat-engine-online-user-search</a><ul><li><a href="Chat.html">Chat</a><ul class='members'></ul><ul class='methods'><li data-type='method'><a href="module-chat-engine-online-user-search.html#~search">search()</a></li></ul></ul></li><li data-sidebar="chat-engine-random-username"><a href="module-chat-engine-random-username.html">chat-engine-random-username</a><ul><li><a href="User.html">User</a><ul class='members'><li data-type='member'><a href="module-chat-engine-random-username.html#~state()%2522.%2522username">state().username</a></li></ul></ul></li><li data-sidebar="chat-engine-typing-indicator"><a href="module-chat-engine-typing-indicator.html">chat-engine-typing-indicator</a><ul><li><a href="Chat.html">Chat</a><ul class='members'></ul><ul class='methods'><li data-type='method'><a href="module-chat-engine-typing-indicator.html#~typingindicator%2522.%2522startTyping">typingindicator.startTyping()</a></li><li data-type='method'><a href="module-chat-engine-typing-indicator.html#~typingindicator%2522.%2522stopTyping">typingindicator.stopTyping()</a></li></ul><ul class='events'><li data-type='event'><a href="module-chat-engine-typing-indicator.html#~event:$typingIndiciator%2522.%2522startTyping">$typingIndiciator.startTyping</a></li><li data-type='event'><a href="module-chat-engine-typing-indicator.html#~event:$typingIndiciator%2522.%2522stopTyping">$typingIndiciator.stopTyping</a></li></ul></ul></li><li data-sidebar="chat-engine-unread-messages"><a href="module-chat-engine-unread-messages.html">chat-engine-unread-messages</a><ul><li><a href="Chat.html">Chat</a><ul class='members'><li data-type='member'><a href="module-chat-engine-unread-messages.html#~unreadCount">unreadCount</a></li></ul><ul class='events'><li data-type='event'><a href="module-chat-engine-unread-messages.html#~event:$unread">$unread</a></li></ul></ul></li><li data-sidebar="chat-engine-uploadcare"><a href="module-chat-engine-uploadcare.html">chat-engine-uploadcare</a><ul><li><a href="Chat.html">Chat</a><ul class='members'></ul><ul class='methods'><li data-type='method'><a href="module-chat-engine-uploadcare.html#~uploadcare%2522.%2522bind">uploadcare.bind()</a></li></ul><ul class='events'><li data-type='event'><a href="module-chat-engine-uploadcare.html#~event:$uploadcare%2522.%2522upload">$uploadcare.upload</a></li></ul></ul></li></ul><h3>Reference</h3><ul><li data-sidebar="Chat"><a href="Chat.html">Chat</a><ul class='members'><li data-type='member'><a href="Chat.html#channel">channel</a></li><li data-type='member'><a href="Chat.html#users">users</a></li></ul><ul class='methods'><li data-type='method'><a href="Chat.html#emit">emit()</a></li><li data-type='method'><a href="Chat.html#history">history()</a></li><li data-type='method'><a href="Chat.html#leave">leave()</a></li><li data-type='method'><a href="Chat.html#off">off()</a></li><li data-type='method'><a href="Chat.html#on">on()</a></li><li data-type='method'><a href="Chat.html#onAny">onAny()</a></li><li data-type='method'><a href="Chat.html#once">once()</a></li><li data-type='method'><a href="Chat.html#plugin">plugin()</a></li></ul><ul class='events'><li data-type='event'><a href="Chat.html#event:$%2522.%2522disconnect">$.disconnect</a></li><li data-type='event'><a href="Chat.html#event:$%2522.%2522join">$.join</a></li><li data-type='event'><a href="Chat.html#event:$%2522.%2522leave">$.leave</a></li><li data-type='event'><a href="Chat.html#event:$%2522.%2522offline">$.offline</a></li><li data-type='event'><a href="Chat.html#event:$%2522.%2522online">$.online</a></li><li data-type='event'><a href="Chat.html#event:$%2522.%2522ready">$.ready</a></li><li data-type='event'><a href="Chat.html#event:$%2522.%2522state">$.state</a></li></ul></li><li data-sidebar="ChatEngine"><a href="ChatEngine.html">ChatEngine</a><ul class='members'><li data-type='member'><a href="ChatEngine.html#.Chat">Chat</a></li><li data-type='member'><a href="ChatEngine.html#.globalChat">globalChat</a></li><li data-type='member'><a href="ChatEngine.html#.me">me</a></li><li data-type='member'><a href="ChatEngine.html#.pubnub">pubnub</a></li><li data-type='member'><a href="ChatEngine.html#.User">User</a></li><li data-type='member'><a href="ChatEngine.html#.users">users</a></li></ul><ul class='methods'><li data-type='method'><a href="ChatEngine.html#.connect">connect()</a></li><li data-type='method'><a href="ChatEngine.html#off">off()</a></li><li data-type='method'><a href="ChatEngine.html#on">on()</a></li><li data-type='method'><a href="ChatEngine.html#onAny">onAny()</a></li><li data-type='method'><a href="ChatEngine.html#once">once()</a></li></ul></li><li data-sidebar="Emitter"><a href="Emitter.html">Emitter</a><ul class='members'></ul><ul class='methods'><li data-type='method'><a href="Emitter.html#off">off()</a></li><li data-type='method'><a href="Emitter.html#on">on()</a></li><li data-type='method'><a href="Emitter.html#onAny">onAny()</a></li><li data-type='method'><a href="Emitter.html#once">once()</a></li><li data-type='method'><a href="Emitter.html#plugin">plugin()</a></li></ul></li><li data-sidebar="Event"><a href="Event.html">Event</a><ul class='members'><li data-type='member'><a href="Event.html#channel">channel</a></li></ul></li><li data-sidebar="Me"><a href="Me.html">Me</a><ul class='members'><li data-type='member'><a href="Me.html#chats">chats</a></li><li data-type='member'><a href="Me.html#direct">direct</a></li><li data-type='member'><a href="Me.html#feed">feed</a></li><li data-type='member'><a href="Me.html#uuid">uuid</a></li></ul><ul class='methods'><li data-type='method'><a href="Me.html#off">off()</a></li><li data-type='method'><a href="Me.html#on">on()</a></li><li data-type='method'><a href="Me.html#onAny">onAny()</a></li><li data-type='method'><a href="Me.html#once">once()</a></li><li data-type='method'><a href="Me.html#plugin">plugin()</a></li><li data-type='method'><a href="Me.html#state">state()</a></li><li data-type='method'><a href="Me.html#update">update()</a></li></ul></li><li data-sidebar="RootEmitter"><a href="RootEmitter.html">RootEmitter</a><ul class='members'></ul><ul class='methods'><li data-type='method'><a href="RootEmitter.html#off">off()</a></li><li data-type='method'><a href="RootEmitter.html#on">on()</a></li><li data-type='method'><a href="RootEmitter.html#onAny">onAny()</a></li><li data-type='method'><a href="RootEmitter.html#once">once()</a></li></ul></li><li data-sidebar="User"><a href="User.html">User</a><ul class='members'><li data-type='member'><a href="User.html#chats">chats</a></li><li data-type='member'><a href="User.html#direct">direct</a></li><li data-type='member'><a href="User.html#feed">feed</a></li><li data-type='member'><a href="User.html#uuid">uuid</a></li></ul><ul class='methods'><li data-type='method'><a href="User.html#off">off()</a></li><li data-type='method'><a href="User.html#on">on()</a></li><li data-type='method'><a href="User.html#onAny">onAny()</a></li><li data-type='method'><a href="User.html#once">once()</a></li><li data-type='method'><a href="User.html#plugin">plugin()</a></li><li data-type='method'><a href="User.html#state">state()</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">chat-engine/src/index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code> "use strict";

// Allows us to create and bind to events. Everything in ChatEngine is an event
// emitter
const EventEmitter2 = require('eventemitter2').EventEmitter2;

const PubNub = require('pubnub');

// allows asynchronous execution flow.
const waterfall = require('async/waterfall');

/**
Global object used to create an instance of {@link ChatEngine}.

@alias ChatEngineCore
@param pnConfig {Object} ChatEngine is based off PubNub. Supply your PubNub configuration parameters here. See the getting started tutorial and [the PubNub docs](https://www.pubnub.com/docs/java-se-java/api-reference-configuration).
@param [globalChannel] {Chat.channel} The global channel name. See {@link ChatEngine.globalChat}
@return {ChatEngine} Returns an instance of {@link ChatEngine}
@example
const ChatEngine = ChatEngineCore.create({
    publishKey: 'demo',
    subscribeKey: 'demo'
}, 'global-channel');
*/
const create = function(pnConfig, globalChannel = 'chat-engine') {

    let ChatEngine = false;

    /**
    * The {@link ChatEngine} object is a RootEmitter. Configures an event emitter that other ChatEngine objects inherit. Adds shortcut methods for
    * ```this.on()```, ```this.emit()```, etc.
    */
    class RootEmitter {

        constructor() {

            /**
            * @private
            */
            this.events = {};

            /**
            Create a new EventEmitter2 object for this class.

            @private
            */
            this.emitter = new EventEmitter2({
              wildcard: true,
              newListener: true,
              maxListeners: 50,
              verboseMemoryLeak: true
            });

            // we bind to make sure wildcards work
            // https://github.com/asyncly/EventEmitter2/issues/186

            /**
            Private emit method that broadcasts the event to listeners on this page.

            @private
            @param {String} event The event name
            @param {Object} the event payload
            */
            this._emit = this.emitter.emit.bind(this.emitter);

            /**
            Listen for a specific event and fire a callback when it's emitted

            @private
            @param {String} event The event name
            @param {Function} callback The function to run when the event is emitted
            */

            this._on = this.emitter.on.bind(this.emitter);

            /**
            Listen for a specific event and fire a callback when it's emitted

            @param {String} event The event name
            @param {Function} cb The function to run when the event is emitted
            */
            this.on = (event, cb) => {

                // keep track of all events on this emitter
                this.events[event] = this.events[event] || new Event(this, event);

                // call the private _on property
                this._on(event, cb);

            };

            /**
            Stop listening to an event
            @method
            @param {String} event The event name
            */
            this.off = this.emitter.off.bind(this.emitter);

            /**
            Listen for any event on this object and fire a callback when it's emitted
            @method
            @param {Function} callback The function to run when any event is emitted. First parameter is the event name and second is the payload.
            */
            this.onAny = this.emitter.onAny.bind(this.emitter);

            /**
            Listen for an event and only fire the callback a single time
            @method
            @param {String} event The event name
            @param {Function} callback The function to run once
            */
            this.once = this.emitter.once.bind(this.emitter);

        }

    }

    /**
    Represents an event that may be emitted or subscribed to.
    */
    class Event {

        constructor(Chat, event) {

            /**
            The [PubNub channel](https://www.pubnub.com/developers/tech/key-concepts/publish-subscribe/channels/) upon which this event is broadcast. Events
            are always a property of a {@link Chat}.

            @readonly
            @type String
            @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)
            */
            this.channel = [Chat.channel, event].join('.');

            /**
            Publishes the event over the PubNub network to the {@link Event} channel

            @private
            @param {Object} data The event payload object
            */
            this.publish = (m) => {

                ChatEngine.pubnub.publish({
                    message: m,
                    channel: this.channel
                });

            }

            /**
            Forwards events to the proper {@link Chat}

            @private
            @param {Object} data The event payload object
            */
            this.onMessage = (m) => {

                if(this.channel == m.channel) {
                    Chat.trigger(event, m.message);
                }

            }

            // call onMessage when PubNub receives an event
            ChatEngine.pubnub.addListener({
                message: this.onMessage
            });

            // subscribe to the PubNub channel for this event
            ChatEngine.pubnub.subscribe({
                channels: [this.channel],
                withPresence: true
            });

        }

    }

    /**
    An ChatEngine generic emitter that supports plugins and forwards
    events to a global emitter.
    @extends RootEmitter
    */
    class Emitter extends RootEmitter {

        constructor() {

            super();

            /**
            Forwards events to the proper {@link Chat}

            @private
            @param {String} event The event payload object
            */
            this._emit = (event, data) => {

                // all events are forwarded to ChatEngine object
                // so you can globally bind to events with ChatEngine.on()
                ChatEngine._emit(event, data);

                // emit the event from the object that created it
                this.emitter.emit(event, data);

            }

            /**
            Stores a list of plugins bound to this object
            @private
            */
            this.plugins = [];

            /**
            Binds a plugin to this object
            @param {Object} module The plugin module
            */
            this.plugin = function(module) {

                // add this plugin to a list of plugins for this object
                this.plugins.push(module);

                // returns the name of this class
                let className = this.constructor.name;

                // see if there are plugins to attach to this class
                if(module.extends &amp;&amp; module.extends[className]) {

                    // attach the plugins to this class
                    // under their namespace
                    ChatEngine.addChild(this, module.namespace,
                        new module.extends[className]);

                    this[module.namespace].ChatEngine = ChatEngine;

                    // if the plugin has a special construct function
                    // run it
                    if(this[module.namespace].construct) {
                        this[module.namespace].construct();
                    }

                }


            }

        }

    }

    /**
    This is the root {@link Chat} class that represents a chat room

    @param {String} channel A unique identifier for this chat {@link Chat}. The channel is the unique name of a {@link Chat}, and is usually something like "The Watercooler", "Support", or "Off Topic". See [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-).
    @extends Emitter
    @fires Chat#$"."ready
    @fires Chat#$"."join
    @fires Chat#$"."online
    @fires Chat#$"."state
    @fires Chat#$"."leave
    @fires Chat#$"."disconnect
    @fires Chat#$"."offline
    */
    class Chat extends Emitter {

        constructor(channel = new Date().getTime()) {

            super();

            /**
            * @type String
            * @readonly
            * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)
            */
            this.channel = channel;

            if(channel.indexOf(globalChannel) == -1) {
                this.channel = [globalChannel, channel].join('.');
            }

            /**
            A list of users in this {@link Chat}. Automatically kept in sync as users join and leave the chat.
            Use [$.join](/Chat.html#event:$%2522.%2522join) and related events to get notified when this changes

            @type Object
            @readonly
            */
            this.users = {};

            /**
            A map of {@link Event} bound to this {@link Chat}

            @private
            @type Object
            @readonly
            */
            this.events = {}

            /**
            Updates list of {@link User}s in this {@link Chat}
            based on who is online now.

            @private
            @param {Object} status The response status
            @param {Object} response The response payload object
            */
            this.onHereNow = (status, response) => {

                if(status.error) {
                    throw new Error('There was a problem fetching here.', status.err);
                } else {

                    // get the list of occupants in this channel
                    let occupants = response.channels[this.channel].occupants;

                    // format the userList for rltm.js standard
                    for(let i in occupants) {
                        this.userUpdate(occupants[i].uuid, occupants[i].state);
                    }

                }

            };

            /**
            Fires when PubNub network connection changes

            @private
            @param {Object} statusEvent The response status
            */
            this.onStatus = (statusEvent) => {

                // if the event says we're connected
                if (statusEvent.category === "PNConnectedCategory") {

                    // and the channel matches this Chat
                    if(statusEvent.affectedChannels.indexOf(this.channel) > -1) {

                        /**
                        * Broadcast that the {@link Chat} is connected to the network.
                        * @event Chat#$"."ready
                        * @example
                        * chat.on('$.ready', () => {
                        *     console.log('chat is ready to go!');
                        * });
                        */
                        this.trigger('$.ready');
                    }

                }

            };

            /**
            Get messages that have been published to the network before this client was connected.
            Events are published with the ```$history``` prefix. So for example, if you had the event ```message```,
            you would call ```Chat.history('message')``` and subscribe to history events via ```chat.on('$history.message', (data) => {})```.

            @param {String} event The name of the event we're getting history for
            @param {Object} [config] The PubNub history config for this call
            */
            this.history = (event, config = {}) => {

                // create the event if it does not exist
                this.events[event] = this.events[event] || new Event(this, event);

                // set the PubNub configured channel to this channel
                config.channel = this.events[event].channel;

                // run the PubNub history method for this event
                ChatEngine.pubnub.history(config, (status, response) => {

                    if(response.error) {
                        throw new Error(response.error);
                    } else {

                        response.messages.forEach((message) => {

                            // trigger the same event with the same data
                            // but the event name is now history:name rather than just name
                            // to distinguish it from the original live events
                            this.trigger(
                                ['$history', event].join('.'),
                                message.entry);

                        });

                    }

                });

            }

            /**
            Keep track of {@link User}s in the room by subscribing to PubNub presence events.

            @private
            @param {Object} data The PubNub presence response for this event
            */
            this.onPresence = (presenceEvent) => {

                // make sure channel matches this channel
                if(this.channel == presenceEvent.channel) {

                    // someone joins channel
                    if(presenceEvent.action == "join") {

                        let user = this.createUser(presenceEvent.uuid, presenceEvent.state);

                        /**
                        * Fired when a {@link User} has joined the room.
                        *
                        * @event Chat#$"."join
                        * @param {Object} data The payload returned by the event
                        * @param {User} data.user The {@link User} that came online
                        * @example
                        * chat.on('$.join', (data) => {
                        *     console.log('User has joined the room!', data.user);
                        * });
                        */
                        this.trigger('$.join', {
                            user: user
                        });

                    }

                    // someone leaves channel
                    if(presenceEvent.action == "leave") {
                        this.userLeave(presenceEvent.uuid);
                    }

                    // someone timesout
                    if(presenceEvent.action == "timeout") {
                        this.userDisconnect(presenceEvent.uuid);
                    }

                    // someone's state is updated
                    if(presenceEvent.action == "state-change") {
                        this.userUpdate(presenceEvent.uuid, presenceEvent.state);
                    }

                }

            };

            // listen to all PubNub events for this Chat
            ChatEngine.pubnub.addListener({
                status: this.onStatus,
                message: this.onMessage,
                presence: this.onPresence
            });

            // subscribe to the PubNub channel for this Chat
            ChatEngine.pubnub.subscribe({
                channels: [this.channel],
                withPresence: true
            });

            // get a list of users online now
            // ask PubNub for information about connected users in this channel
            ChatEngine.pubnub.hereNow({
                channels: [this.channel],
                includeUUIDs: true,
                includeState: true
            }, this.onHereNow);

        }

        /**
        Send events to other clients in this {@link User}.
        Events are trigger over the network  and all events are made
        on behalf of {@link Me}

        @param {String} event The event name
        @param {Object} data The event payload object
        */
        emit(event, data) {

            // create a standardized payload object
            let payload = {
                data: data,            // the data supplied from params
                sender: ChatEngine.me.uuid,   // my own uuid
                chat: this,            // an instance of this chat
            };

            // run the plugin queue to modify the event
            this.runPluginQueue('emit', event, (next) => {
                next(null, payload);
            }, (err, payload) => {

                // remove chat otherwise it would be serialized
                // instead, it's rebuilt on the other end.
                // see this.trigger
                delete payload.chat;

                // publish the event and data over the configured channel

                // ensure the event exists within the global space
                this.events[event] = this.events[event] || new Event(this, event);

                this.events[event].publish(payload);

            });

        }

        /**
        Broadcasts an event locally to all listeners.

        @private
        @param {String} event The event name
        @param {Object} payload The event payload object
        */
        trigger(event, payload) {

            if(typeof payload == "object") {

                // restore chat in payload
                if(!payload.chat) {
                    payload.chat = this;
                }

                // turn a uuid found in payload.sender to a real user
                if(payload.sender &amp;&amp; ChatEngine.users[payload.sender]) {
                    payload.sender = ChatEngine.users[payload.sender];
                }

            }

            // let plugins modify the event
            this.runPluginQueue('on', event, (next) => {
                next(null, payload);
            }, (err, payload) => {

                // emit this event to any listener
                this._emit(event, payload);

            });

        }

        /**
        Add a user to the {@link Chat}, creating it if it doesn't already exist.

        @private
        @param {String} uuid The user uuid
        @param {Object} state The user initial state
        @param {Boolean} trigger Force a trigger that this user is online
        */
        createUser(uuid, state, trigger = false) {

            // Ensure that this user exists in the global list
            // so we can reference it from here out
            ChatEngine.users[uuid] = ChatEngine.users[uuid] || new User(uuid);

            // Add this chatroom to the user's list of chats
            ChatEngine.users[uuid].addChat(this, state);

            // trigger the join event over this chatroom
            if(!this.users[uuid] || trigger) {

                /**
                * Broadcast that a {@link User} has come online. This is when
                * the framework firsts learn of a user. This can be triggered
                * by, ```$.join```, or other network events that
                * notify the framework of a new user.
                *
                * @event Chat#$"."online
                * @param {Object} data The payload returned by the event
                * @param {User} data.user The {@link User} that came online
                * @example
                * chat.on('$.online', (data) => {
                *     console.log('User has come online:', data.user);
                * });
                */
                this.trigger('$.online', {
                    user: ChatEngine.users[uuid]
                });

            }

            // store this user in the chatroom
            this.users[uuid] = ChatEngine.users[uuid];

            // return the instance of this user
            return ChatEngine.users[uuid];

        }

        /**
        * Update a user's state within this {@link Chat}.
        * @private
        * @param {String} uuid The {@link User} uuid
        * @param {Object} state State to update for the user
        */
        userUpdate(uuid, state) {

            // ensure the user exists within the global space
            ChatEngine.users[uuid] = ChatEngine.users[uuid] || new User(uuid);

            // if we don't know about this user
            if(!this.users[uuid]) {
                // do the whole join thing
                this.createUser(uuid, state);
            }

            // update this user's state in this chatroom
            this.users[uuid].assign(state, this);

            /**
            * Broadcast that a {@link User} has changed state.
            * @event Chat#$"."state
            * @param {Object} data The payload returned by the event
            * @param {User} data.user The {@link User} that changed state
            * @param {Object} data.state The new user state for this ```Chat```
            * @example
            * chat.on('$.state', (data) => {
            *     console.log('User has changed state:', data.user, 'new state:', data.state);
            * });
            */
            this.trigger('$.state', {
                user: this.users[uuid],
                state: this.users[uuid].state(this)
            });

        }

        /**
        Leave from the {@link Chat} on behalf of {@link Me}.
        */
        leave() {

            ChatEngine.pubnub.unsubscribe({
                channels: [this.channel]
            });

        }

        /**
        Perform updates when a user has left the {@link Chat}.

        @private
        */
        userLeave(uuid) {

            // make sure this event is real, user may have already left
            if(this.users[uuid]) {

                // if a user leaves, trigger the event

                /**
                * Fired when a {@link User} intentionally leaves a {@link Chat}.
                *
                * @event Chat#$"."leave
                * @param {User} user The {@link User} that has left the room
                * @example
                * chat.on('$.leave', (user) => {
                *     console.log('User left the room manually:', user);
                * });
                */
                this.trigger('$.leave', this.users[uuid]);
                this.trigger('$.offline', this.users[uuid]);

                // remove the user from the local list of users
                delete this.users[uuid];

                // we don't remove the user from the global list,
                // because they may be online in other channels

            } else {

                // that user isn't in the user list
                // we never knew about this user or they already left

                // console.log('user already left');
            }
        }

        /**
        Fired when a user disconnects from the {@link Chat}

        @private
        @param {String} uuid The uuid of the {@link Chat} that left
        */
        userDisconnect(uuid) {

            // make sure this event is real, user may have already left
            if(this.users[uuid]) {

                /**
                * Fired specifically when a {@link User} looses network connection
                * to the {@link Chat} involuntarily.
                *
                * @event Chat#$"."disconnect
                * @param {Object} User The {@link User} that disconnected
                * @example
                * chat.on('$.disconnect', (user) => {
                *     console.log('User disconnected from the network:', user);
                * });
                */
                this.trigger('$.disconnect', this.users[uuid]);

                /**
                * A {@link User} has gone offline. Triggered by ```$.leave```
                * or ```$.disconnect```.
                *
                * @event Chat#$"."offline
                * @param {User} user The {@link User} that has gone offline
                * @example
                * chat.on('$.offline', (user) => {
                *     console.log('User disconnected from the network:', user);
                * });
                */
                this.trigger('$.offline', this.users[uuid]);

            }

        }

        /**
        Load plugins and attach a queue of functions to execute before and
        after events are trigger or received.

        @private
        @param {String} location Where in the middleeware the event should run (emit, trigger)
        @param {String} event The event name
        @param {String} first The first function to run before the plugins have run
        @param {String} last The last function to run after the plugins have run
        */
        runPluginQueue(location, event, first, last) {

            // this assembles a queue of functions to run as middleware
            // event is a triggered event key
            let plugin_queue = [];

            // the first function is always required
            plugin_queue.push(first);

            // look through the configured plugins
            for(let i in this.plugins) {

                // if they have defined a function to run specifically
                // for this event
                if(this.plugins[i].middleware
                    &amp;&amp; this.plugins[i].middleware[location]
                    &amp;&amp; this.plugins[i].middleware[location][event]) {

                    // add the function to the queue
                    plugin_queue.push(
                        this.plugins[i].middleware[location][event]);
                }

            }

            // waterfall runs the functions in assigned order
            // waiting for one to complete before moving to the next
            // when it's done, the ```last``` parameter is called
            waterfall(plugin_queue, last);

        }

        /**
        Set the state for {@link Me} within this {@link User}.
        Broadcasts the ```$.state``` event on other clients

        @private
        @param {Object} state The new state {@link Me} will have within this {@link User}
        */
        setState(state) {

            ChatEngine.pubnub.setState(
                {
                    state: state,
                    channels: [this.channel]
                },
                function (status, response) {
                    // handle status, response
                }
            );

        }

    };

    /**
    This is our User class which represents a connected client.
    @class
    @extends Emitter
    @param uuid
    @param state
    @param chat
    */
    class User extends Emitter {

        constructor(uuid, state = {}, chat = ChatEngine.globalChat) {

            super();

            /**
            The User's unique identifier, usually a device uuid. This helps ChatEngine identify the user between events. This is public id exposed to the network.
            Check out [the wikipedia page on UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).

            @readonly
            @type String
            */
            this.uuid = uuid;

            /**
            A map of the User's state in each {@link Chat}. Stays in sync automatically.

            @private
            @type Object
            */
            this.states = {};

            /**
            * An object containing the Chats this {@link User} is currently in. The key of each item in the object is the {@link Chat.channel} and the value is the {@link Chat} object. Note that for privacy, this map will only contain {@link Chat}s that the client ({@link Me}) is also connected to.
            *
            * @readonly
            * @type Object
            * @example
            *{
            *    "globalChannel": {
            *        channel: "globalChannel",
            *        users: {
            *            //...
            *        },
            *    },
            *    // ...
            * }
            */
            this.chats = {};

            /**
            Feed is a Chat that only streams things a User does, like
            'startTyping' or 'idle' events for example. Anybody can subscribe
            to a User's feed, but only the User can publish to it (security not yet implemented).

            @type Chat
            */
            this.feed = new Chat(
                [ChatEngine.globalChat.channel, uuid, 'feed'].join('.'));

            /**
            Direct is a private channel that anybody can publish to but only the user can subscribe to. Great
            for pushing notifications or inviting to other chats. (security not implemented yet).

            @type Chat
            */
            this.direct = new Chat(
                [ChatEngine.globalChat.channel, uuid, 'direct'].join('.'));

            // if the user does not exist at all and we get enough
            // information to build the user
            if(!ChatEngine.users[uuid]) {
                ChatEngine.users[uuid] = this;
            }

            // update this user's state in it's created context
            this.assign(state, chat)

        }

        /**
        Gets the user state in a {@link Chat}.
        @param {Chat} chat Chatroom to retrieve state from
        */
        state(chat = ChatEngine.globalChat) {
            return this.states[chat.channel] || {};
        }

        /**
        * @private
        * @param {Object} state The new state for the user
        * @param {Chat} chat Chatroom to retrieve state from
        */
        update(state, chat = ChatEngine.globalChat) {
            let chatState = this.state(chat) || {};
            this.states[chat.channel] = Object.assign(chatState, state);
        }

        /**
        this is only called from network updates

        @private
        */
        assign(state, chat) {
            this.update(state, chat);
        }

        /**
        adds a chat to this user

        @private
        */
        addChat(chat, state) {

            // store the chat in this user object
            this.chats[chat.channel] = chat;

            // updates the user's state in that chatroom
            this.assign(state, chat);
        }

    }

    /**
    Represents the client connection as a special {@link User} with write permissions.
    Has the ability to update it's state on the network. An instance of
    {@link Me} is returned by the ```ChatEngine.connect()```
    method.

    @class Me
    @param {String} uuid The uuid of this user
    @extends User
    */
    class Me extends User {

        constructor(uuid) {

            // call the User constructor
            super(uuid);

        }

        // assign updates from network
        assign(state, chat) {
            // we call "update" because calling "super.assign"
            // will direct back to "this.update" which creates
            // a loop of network updates
            super.update(state, chat);
        }

        /**
        Update {@link Me}'s state in a {@link Chat}. All {@link User}s in the {@link Chat} will be notified of this change via ($.update)[Chat.html#event:$%2522.%2522state].
        @param {Object} state The new state for {@link Me}
        @param {Chat} chat An instance of the {@link Chat} where state will be updated.
        Defaults to ```ChatEngine.globalChat```.
        @fires Chat#event:$"."state
        */
        update(state, chat = ChatEngine.globalChat) {

            // run the root update function
            super.update(state, chat);

            // publish the update over the global channel
            chat.setState(state);

        }

    }

    /**
    Provides the base Widget class...

    @class ChatEngine
    @extends RootEmitter
     */
    const init = function() {

        // Create the root ChatEngine object
        ChatEngine = new RootEmitter;

        /**
        * A map of all known users in this instance of ChatEngine
        * @memberof ChatEngine
        */
        ChatEngine.users = {};

        /**
        * A global {@link Chat} that all {@link User}s join when they connect to ChatEngine. Useful for announcements, alerts, and global events.
        * @member globalChat
        * @memberof ChatEngine
        */
        ChatEngine.globalChat = false;

        /**
        * This instance of ChatEngine represented as a special {@link User} know as {@link Me}
        * @member {Me} me
        * @memberof ChatEngine
        */
        ChatEngine.me = false;

        /**
        * An instance of PubNub, the networking infrastructure that powers the realtime communication between {@link User}s in {@link Chats}.
        * @member {Object} pubnub
        * @memberof ChatEngine
        */
        ChatEngine.pubnub = false;

        /**
        connect to realtime service and create instance of {@link Me}
        *
        @memberof ChatEngine
        @param {String} uuid A unique string for {@link Me}. It can be a device id, username, user id, email, etc.
        @param {Object} state An object containing information about this client ({@link Me}). This JSON object is sent to all other clients on the network, so no passwords!
        @return {Me} me an instance of me
        */
        ChatEngine.connect = function(uuid, state = {}) {

            // this creates a user known as Me and
            // connects to the global chatroom

            // this.config.rltm.config.uuid = uuid;
            pnConfig.uuid = uuid || pnConfig.uuid;

            this.pubnub = new PubNub(pnConfig);

            // create a new chat to use as globalChat
            this.globalChat = new Chat(globalChannel);

            // create a new user that represents this client
            this.me = new Me(this.pubnub.getUUID());

            // create a new instance of Me using input parameters
            this.globalChat.createUser(this.pubnub.getUUID(), state);

            this.me.update(state);

            // return me
            return this.me;

            // client can access globalChat through ChatEngine.globalChat

        };

        /**
        * The {@link Chat} class.
        * @member {Chat} Chat
        * @memberof ChatEngine
        * @see {@link Chat}
        */
        ChatEngine.Chat = Chat;

        /**
        * The {@link User} class.
        * @member {User} User
        * @memberof ChatEngine
        * @see {@link User}
        */
        ChatEngine.User = User;

        // add an object as a subobject under a namespoace
        ChatEngine.addChild = (ob, childName, childOb) => {

            // assign the new child object as a property of parent under the
            // given namespace
            ob[childName] = childOb;

            // the new object can use ```this.parent``` to access
            // the root class
            childOb.parent = ob;

        }

        return ChatEngine;

    }

    // return an instance of ChatEngine
    return init();

}

// export the ChatEngine api
module.exports = {
    plugin: {},  // leave a spot for plugins to exist
    create: create
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.2</a> on Mon Jul 31 2017 18:39:28 GMT-0500 (CDT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
